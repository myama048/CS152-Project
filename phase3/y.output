Nonterminals useless in grammar

   Function
   Declarations
   declaration
   Identifiers
   identifier
   Statements
   statement
   Vars
   Var
   Bool_Expr
   Relation_And_Expr
   Relation_Expr
   Comp
   Expressions
   Expression
   Multiplicative_Expr
   Term


Terminals unused in grammar

   FUNCTION
   BEGIN_PARAMS
   END_PARAMS
   BEGIN_LOCALS
   END_LOCALS
   BEGIN_BODY
   END_BODY
   INTEGER
   ARRAY
   ENUM
   OF
   IF
   THEN
   ENDIF
   ELSE
   WHILE
   DO
   BEGIN_LOOP
   END_LOOP
   CONTINUE
   READ
   WRITE
   AND
   OR
   NOT
   TRUE
   FALSE
   RETURN
   SUB
   ADD
   MULT
   DIV
   MOD
   EQ
   NEQ
   LT
   GT
   LTE
   GTE
   SEMICOLON
   COLON
   COMMA
   L_PAREN
   R_PAREN
   L_SQUARE_BRACKET
   R_SQUARE_BRACKET
   ASSIGN
   END
   IDENT
   NUMBER


Rules useless in grammar

    3 Functions: Function
    4          | Function Functions

    5 Function: FUNCTION identifier SEMICOLON BEGIN_PARAMS Declarations END_PARAMS BEGIN_LOCALS Declarations END_LOCALS BEGIN_BODY Statements END_BODY

    6 Declarations: declaration SEMICOLON Declarations

    7 declaration: Identifiers COLON ENUM L_PAREN Identifiers R_PAREN
    8            | Identifiers COLON INTEGER
    9            | Identifiers COLON ARRAY L_SQUARE_BRACKET NUMBER R_SQUARE_BRACKET OF INTEGER

   10 Identifiers: identifier
   11            | identifier COMMA Identifiers

   12 identifier: IDENT

   13 Statements: statement SEMICOLON Statements
   14           | statement SEMICOLON

   15 statement: Var ASSIGN Expression
   16          | IF Bool_Expr THEN Statements ENDIF
   17          | IF Bool_Expr THEN Statements ELSE Statements ENDIF
   18          | WHILE Bool_Expr BEGIN_LOOP Statements END_LOOP
   19          | DO BEGIN_LOOP Statements END_LOOP WHILE Bool_Expr
   20          | READ Vars
   21          | WRITE Vars
   22          | CONTINUE
   23          | RETURN Expression

   24 Vars: Var
   25     | Var COMMA Vars

   26 Var: identifier
   27    | identifier L_SQUARE_BRACKET Expression R_SQUARE_BRACKET

   28 Bool_Expr: Relation_And_Expr OR Bool_Expr
   29          | Relation_And_Expr

   30 Relation_And_Expr: Relation_Expr AND Relation_And_Expr
   31                  | Relation_Expr

   32 Relation_Expr: Expression Comp Expression
   33              | TRUE
   34              | FALSE
   35              | L_PAREN Bool_Expr R_PAREN
   36              | NOT Expression Comp Expression
   37              | NOT TRUE
   38              | NOT FALSE
   39              | NOT L_PAREN Bool_Expr R_PAREN

   40 Comp: EQ
   41     | NEQ
   42     | LT
   43     | GT
   44     | GTE
   45     | LTE

   46 Expressions: %empty
   47            | Expression
   48            | Expression COMMA Expressions

   49 Expression: Multiplicative_Expr
   50           | Multiplicative_Expr ADD Expression
   51           | Multiplicative_Expr SUB Expression

   52 Multiplicative_Expr: Term
   53                    | Term MULT Multiplicative_Expr
   54                    | Term DIV Multiplicative_Expr
   55                    | Term MOD Multiplicative_Expr

   56 Term: Var
   57     | SUB Var
   58     | NUMBER
   59     | SUB NUMBER
   60     | L_PAREN Expression R_PAREN
   61     | SUB L_PAREN Expression R_PAREN
   62     | identifier L_PAREN Expressions R_PAREN


Grammar

    0 $accept: prog_start $end

    1 prog_start: Functions

    2 Functions: %empty


Terminals, with rules where they appear

$end (0) 0
error (256)
FUNCTION (258)
BEGIN_PARAMS (259)
END_PARAMS (260)
BEGIN_LOCALS (261)
END_LOCALS (262)
BEGIN_BODY (263)
END_BODY (264)
INTEGER (265)
ARRAY (266)
ENUM (267)
OF (268)
IF (269)
THEN (270)
ENDIF (271)
ELSE (272)
WHILE (273)
DO (274)
BEGIN_LOOP (275)
END_LOOP (276)
CONTINUE (277)
READ (278)
WRITE (279)
AND (280)
OR (281)
NOT (282)
TRUE (283)
FALSE (284)
RETURN (285)
SUB (286)
ADD (287)
MULT (288)
DIV (289)
MOD (290)
EQ (291)
NEQ (292)
LT (293)
GT (294)
LTE (295)
GTE (296)
SEMICOLON (297)
COLON (298)
COMMA (299)
L_PAREN (300)
R_PAREN (301)
L_SQUARE_BRACKET (302)
R_SQUARE_BRACKET (303)
ASSIGN (304)
END (305)
IDENT (306)
NUMBER (307)


Nonterminals, with rules where they appear

$accept (53)
    on left: 0
prog_start (54)
    on left: 1, on right: 0
Functions (55)
    on left: 2, on right: 1


State 0

    0 $accept: . prog_start $end

    $default  reduce using rule 2 (Functions)

    prog_start  go to state 1
    Functions   go to state 2


State 1

    0 $accept: prog_start . $end

    $end  shift, and go to state 3


State 2

    1 prog_start: Functions .

    $default  reduce using rule 1 (prog_start)


State 3

    0 $accept: prog_start $end .

    $default  accept
